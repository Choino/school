public boolean hasPrevious(){   return (nextIndex > 0) && (nextIndex <= numberOfEntries);} // end hasPreviouspublic T previous(){   if (hasPrevious())   {      lastMove = Move.PREVIOUS;      isRemoveOrSetLegal = true;      nextIndex--;      return list[nextIndex];   }   else      throw new NoSuchElementException("Illegal call to previous();" +                                       "iterator is before beginning of list.");} // end previous