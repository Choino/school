// CS 401 Fall 2011
// Compare to ex15b and ex15c.  Now we have added a JTextField to the
// JFrame, which allows us to change the label on the JButton.  However,
// since we need to access both the JButton and the JTextField from the
// same ActionListener, the program is now written in a fundamentally
// different way:
// -- Note that the component references are now instance variables, not
//    method variables.
// -- Now the "setup" of the JFrame is done in the constructor, not in the
//    main program.  The main program simply creates an ex15d object and
//    the rest is handled within the constructor.
// -- The MyListener class is now an INNER CLASS -- this means that it is
//    declared WITHIN another class.  This allows MyListener to access the
//    instance variables of the ex15d class, so it can access the JButton
//    and JTextField references directly.

// If you compare the general structure of this program with the previous
// three, you will see that this is in fact more "object-oriented" in its
// design.  Note how simple the main() method is.  Most of the work is
// done through objects in the program interacting with each other.

import java.awt.*;
import javax.swing.*;
import java.awt.event.*;

public class ex15d
{
	private JFrame theWindow;
	private JButton theButton;
	private Container thePane;
	private JTextField theText;
	private MyListener theListener;

	public ex15d()
	{
		theWindow = new JFrame("Example 15d");
		theWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		
		theButton = new JButton("Change Color");
		theButton.setFont(new Font("Serif", Font.ITALIC + Font.BOLD, 48));
		
		theListener = new MyListener();
		theButton.addActionListener(theListener);

		theText = new JTextField();
		theText.setFont(new Font("Serif", Font.BOLD, 48));
		theText.addActionListener(theListener);

		Container thePane = theWindow.getContentPane();
		thePane.setLayout(new GridLayout(1,2));
		thePane.add(theButton);
		thePane.add(theText);

		//theWindow.setSize(400, 200);
		theWindow.pack();
		theWindow.setVisible(true);
	}

	// Note that BOTH the JButton and the JTextField are using the
	// same ActionListener, as defined below.  This is not required,
	// but it is convenient in this case.  Because different events
	// could trigger this listener, the actionPerformed method must
	// test to see which reference actually generated the ActionEvent.
	class MyListener implements ActionListener
	{
		// Inner classes are not allowed to have static variables,
		// so these are now regular instance variables.
		final Color [] theColors = {Color.RED, Color.BLUE, Color.CYAN,
									 Color.ORANGE, Color.MAGENTA};
		int index = 0;

		public void actionPerformed(ActionEvent e)
		{
			Component theEventer = (Component) e.getSource();
			// If event was generated by the JButton, do as we did
			// in ex13b -- change the color
			if (theEventer == theButton)
			{
				theEventer.setForeground(theColors[index]);
				index = (index + 1) % theColors.length;
			}
			// If event was generated by the JTextField, take the
			// text from the JTextField and use it to set the text
			// of the JButton.  Then blank out the JTextField.
			else if (theEventer == theText)
			{
				theButton.setText(theText.getText());
				theText.setText("");
			}
		}
	}

	// Note how simple the main is here -- just one line.  Creating
	// the object causes the constructor to be called, which sets up
	// the JFrame.  Even though it looks like the program should then
	// end, when graphical components are used, the program will not
	// terminate unless done so explicitly (through closing the window
	// in this case).
	public static void main(String [] args)
	{
		new ex15d();
	}
}


